package pages

import (
	"arabica/internal/models"
	"arabica/internal/web/bff"
	"arabica/internal/web/components"
	"fmt"
)

// BrewViewProps defines the data for the brew view page
type BrewViewProps struct {
	Brew            *models.Brew
	IsOwnProfile    bool
	IsAuthenticated bool
	SubjectURI      string // AT-URI of the brew (for like button)
	SubjectCID      string // CID of the brew (for like button)
	IsLiked         bool   // Whether the current user has liked this brew
	LikeCount       int    // Number of likes on this brew
	ShareURL        string // URL for sharing the brew
}

// BrewView renders the full brew view page
templ BrewView(layout *components.LayoutData, props BrewViewProps) {
	@components.Layout(layout, BrewViewContent(props))
}

// BrewViewContent renders the brew view page content
templ BrewViewContent(props BrewViewProps) {
	<div class="page-container-sm">
		@components.Card(components.CardProps{InnerCard: true}, BrewViewCard(props))
	</div>
}

// BrewViewCard renders the brew details card
templ BrewViewCard(props BrewViewProps) {
	@BrewViewHeader(props)
	<div class="space-y-6">
		if props.Brew.Rating > 0 {
			@BrewRating(props.Brew.Rating)
		}
		@BrewBeanSection(props.Brew)
		@BrewParametersGrid(props.Brew)
		if props.Brew.Pours != nil && len(props.Brew.Pours) > 0 {
			@BrewPoursSection(props.Brew.Pours)
		}
		if props.Brew.TastingNotes != "" {
			@BrewTastingNotes(props.Brew.TastingNotes)
		}
		<div class="flex justify-between items-center">
			@components.BackButton()
			<div class="bg-brown-50 rounded-lg px-3 py-2 border border-brown-200">
				@components.SocialButtons(components.SocialButtonsProps{
					SubjectURI:      props.SubjectURI,
					SubjectCID:      props.SubjectCID,
					IsLiked:         props.IsLiked,
					LikeCount:       props.LikeCount,
					ShareURL:        props.ShareURL,
					ShareTitle:      getBrewShareTitle(props.Brew),
					ShareText:       "Check out this brew on Arabica",
					ShowLike:        props.IsAuthenticated,
					IsAuthenticated: props.IsAuthenticated,
				})
			</div>
		</div>
	</div>
}

// BrewViewHeader renders the header with title and actions
templ BrewViewHeader(props BrewViewProps) {
	<div class="flex justify-between items-start mb-6">
		<div>
			<h2 class="text-3xl font-bold text-brown-900">Brew Details</h2>
			<p class="text-sm text-brown-600 mt-1">{ props.Brew.CreatedAt.Format("January 2, 2006 at 3:04 PM") }</p>
		</div>
		if props.IsOwnProfile {
			<div class="flex gap-2">
				<a
					href={ templ.SafeURL("/brews/" + props.Brew.RKey + "/edit") }
					class="inline-flex items-center btn-secondary"
				>
					Edit
				</a>
				<button
					hx-delete={ "/brews/" + props.Brew.RKey }
					hx-confirm="Are you sure you want to delete this brew?"
					hx-target="body"
					class="inline-flex items-center bg-brown-200 text-brown-700 px-4 py-2 rounded-lg hover:bg-brown-300 font-medium transition-colors"
				>
					Delete
				</button>
			</div>
		}
	</div>
}

// BrewRating renders the prominent rating display
templ BrewRating(rating int) {
	<div class="section-box text-center py-4">
		<div class="text-4xl font-bold text-brown-800">
			{ fmt.Sprintf("%d/10", rating) }
		</div>
		<div class="text-sm text-brown-600 mt-1">Rating</div>
	</div>
}

// BrewBeanSection renders the coffee bean information
templ BrewBeanSection(brew *models.Brew) {
	<div class="section-box">
		<h3 class="text-sm font-medium text-brown-600 uppercase tracking-wider mb-2">Coffee Bean</h3>
		if brew.Bean != nil {
			<div class="font-bold text-lg text-brown-900">
				if brew.Bean.Name != "" {
					{ brew.Bean.Name }
				} else {
					{ brew.Bean.Origin }
				}
			</div>
			if brew.Bean.Roaster != nil && brew.Bean.Roaster.Name != "" {
				<div class="text-sm text-brown-700 mt-1">
					by { brew.Bean.Roaster.Name }
				</div>
			}
			<div class="flex flex-wrap gap-3 mt-2 text-sm text-brown-600">
				if brew.Bean.Origin != "" {
					<span>Origin: { brew.Bean.Origin }</span>
				}
				if brew.Bean.RoastLevel != "" {
					<span>Roast: { brew.Bean.RoastLevel }</span>
				}
			</div>
		} else {
			<span class="text-brown-400">Not specified</span>
		}
	</div>
}

// BrewParametersGrid renders the brew parameters in a grid
templ BrewParametersGrid(brew *models.Brew) {
	<div class="grid grid-cols-2 gap-4">
		@BrewParameter("Coffee", getCoffeeAmountDisplay(brew))
		@BrewParameter("Brew Method", getBrewerName(brew))
		@BrewParameter("Grinder", getGrinderName(brew))
		@BrewParameter("Grind Size", getGrindSizeDisplay(brew))
		@BrewParameter("Water", getWaterAmountDisplay(brew))
		@BrewParameter("Temperature", getTemperatureDisplay(brew))
		<div class="col-span-2">
			@BrewParameter("Brew Time", getBrewTimeDisplay(brew))
		</div>
	</div>
}

// BrewParameter renders a single parameter in the grid
templ BrewParameter(label string, value string) {
	<div class="section-box">
		<h3 class="text-sm font-medium text-brown-600 uppercase tracking-wider mb-2">{ label }</h3>
		if value != "" {
			<div class="font-semibold text-brown-900">{ value }</div>
		} else {
			<span class="text-brown-400">Not specified</span>
		}
	</div>
}

// Helper functions for brew view display
func getBrewerName(brew *models.Brew) string {
	if brew.BrewerObj != nil {
		return brew.BrewerObj.Name
	}
	if brew.Method != "" {
		return brew.Method
	}
	return ""
}

func getGrinderName(brew *models.Brew) string {
	if brew.GrinderObj != nil {
		return brew.GrinderObj.Name
	}
	return ""
}

func getCoffeeAmountDisplay(brew *models.Brew) string {
	if brew.CoffeeAmount > 0 {
		return fmt.Sprintf("%dg", brew.CoffeeAmount)
	}
	return ""
}

func getWaterAmountDisplay(brew *models.Brew) string {
	if brew.WaterAmount > 0 {
		return fmt.Sprintf("%dg", brew.WaterAmount)
	}
	// If water amount not set, sum from pours
	if len(brew.Pours) > 0 {
		totalWater := 0
		for _, pour := range brew.Pours {
			totalWater += pour.WaterAmount
		}
		if totalWater > 0 {
			return fmt.Sprintf("%dg", totalWater)
		}
	}
	return ""
}

func getGrindSizeDisplay(brew *models.Brew) string {
	return brew.GrindSize
}

func getTemperatureDisplay(brew *models.Brew) string {
	if brew.Temperature > 0 {
		return bff.FormatTemp(brew.Temperature)
	}
	return ""
}

func getBrewTimeDisplay(brew *models.Brew) string {
	if brew.TimeSeconds > 0 {
		return bff.FormatTime(brew.TimeSeconds)
	}
	return ""
}

func getBrewShareTitle(brew *models.Brew) string {
	if brew.Bean != nil {
		if brew.Bean.Name != "" {
			return brew.Bean.Name
		}
		return brew.Bean.Origin
	}
	return "Coffee Brew"
}

// BrewPoursSection renders the pours section
templ BrewPoursSection(pours []*models.Pour) {
	<div class="section-box">
		<h3 class="text-sm font-medium text-brown-600 uppercase tracking-wider mb-3">Pours</h3>
		<div class="space-y-2">
			for _, pour := range pours {
				<div class="flex justify-between items-center bg-white p-3 rounded-lg border border-brown-200">
					<div class="flex gap-4 text-sm">
						<span class="font-semibold text-brown-800">{ fmt.Sprintf("%dg", pour.WaterAmount) }</span>
						// TODO: add a setting to allow users to configure "at" vs "for" in pours display here
						<span class="text-brown-600">{ "for " + bff.FormatTime(pour.TimeSeconds) }</span>
					</div>
				</div>
			}
		</div>
	</div>
}

// BrewTastingNotes renders the tasting notes section
templ BrewTastingNotes(notes string) {
	<div class="section-box">
		<h3 class="text-sm font-medium text-brown-600 uppercase tracking-wider mb-2">Tasting Notes</h3>
		<div class="text-brown-900 whitespace-pre-wrap">{ notes }</div>
	</div>
}
