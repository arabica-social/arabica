package pages

import (
	"arabica/internal/feed"
	"arabica/internal/lexicons"
	"arabica/internal/web/components"
	"fmt"
)

// FeedModerationContext holds moderation state for rendering feed items
type FeedModerationContext struct {
	IsModerator   bool            // User has moderator role
	CanHideRecord bool            // User has hide_record permission
	CanBlockUser  bool            // User has blacklist_user permission
	HiddenURIs    map[string]bool // URIs that are currently hidden
}

// FeedQueryState holds the current filter/sort/pagination state
type FeedQueryState struct {
	TypeFilter      string // Current type filter (empty = all)
	Sort            string // Current sort order
	NextCursor      string // Cursor for next page (empty = no more)
	IsAuthenticated bool
}

// feedFilterTab defines a filter tab option
type feedFilterTab struct {
	Label string
	Value string
}

func feedFilterTabs() []feedFilterTab {
	return []feedFilterTab{
		{Label: "All", Value: ""},
		{Label: "Brews", Value: "brew"},
		{Label: "Beans", Value: "bean"},
		{Label: "Roasters", Value: "roaster"},
		{Label: "Grinders", Value: "grinder"},
		{Label: "Brewers", Value: "brewer"},
	}
}

func buildFeedURL(typeFilter, sort string) string {
	url := "/api/feed"
	sep := "?"
	if typeFilter != "" {
		url += sep + "type=" + typeFilter
		sep = "&"
	}
	if sort != "" && sort != "recent" {
		url += sep + "sort=" + sort
	}
	return url
}

func buildFeedURLWithCursor(typeFilter, sort, cursor string) string {
	url := buildFeedURL(typeFilter, sort)
	if cursor != "" {
		if len(url) > len("/api/feed") {
			url += "&cursor=" + cursor
		} else {
			url += "?cursor=" + cursor
		}
	}
	return url
}

// FeedPartial renders the feed items (for HTMX loading)
templ FeedPartial(items []*feed.FeedItem, isAuthenticated bool) {
	@FeedPartialWithModeration(items, isAuthenticated, FeedModerationContext{}, FeedQueryState{IsAuthenticated: isAuthenticated})
}

// FeedPartialWithModeration renders feed items with moderation context
templ FeedPartialWithModeration(items []*feed.FeedItem, isAuthenticated bool, modCtx FeedModerationContext, qs FeedQueryState) {
	<div id="feed-container">
		<!-- Filter tabs (authenticated only) -->
		if isAuthenticated {
			@FeedFilterBar(qs)
		}
		<!-- Feed items -->
		<div id="feed-items" class="space-y-4">
			if len(items) > 0 {
				for _, item := range items {
					@FeedCardWithModeration(item, isAuthenticated, modCtx)
				}
				<!-- Load more button -->
				if qs.NextCursor != "" {
					@FeedLoadMoreButton(qs)
				}
			} else {
				<div class="bg-brown-100 rounded-lg p-6 text-center text-brown-700 border border-brown-200">
					<p class="mb-2 font-medium">No activity in the feed yet.</p>
					<p class="text-sm">Be the first to add something!</p>
				</div>
			}
		</div>
	</div>
}

// FeedFilterBar renders the type filter tabs and sort selector
templ FeedFilterBar(qs FeedQueryState) {
	<div class="flex flex-wrap items-center justify-between gap-2 mb-4">
		<!-- Type filter tabs -->
		<div class="flex flex-wrap gap-1">
			for _, tab := range feedFilterTabs() {
				<button
					class={ "px-3 py-1.5 text-sm rounded-full transition-colors",
						templ.KV("bg-brown-800 text-brown-50 font-medium", qs.TypeFilter == tab.Value),
						templ.KV("bg-brown-100 text-brown-700 hover:bg-brown-200", qs.TypeFilter != tab.Value) }
					hx-get={ buildFeedURL(tab.Value, qs.Sort) }
					hx-target="#feed-container"
					hx-swap="outerHTML"
				>
					{ tab.Label }
				</button>
			}
		</div>
		<!-- Sort selector -->
		<div class="flex items-center gap-1">
			<button
				class={ "px-3 py-1.5 text-sm rounded-full transition-colors",
					templ.KV("bg-brown-800 text-brown-50 font-medium", qs.Sort == "" || qs.Sort == "recent"),
					templ.KV("bg-brown-100 text-brown-700 hover:bg-brown-200", qs.Sort != "" && qs.Sort != "recent") }
				hx-get={ buildFeedURL(qs.TypeFilter, "recent") }
				hx-target="#feed-container"
				hx-swap="outerHTML"
			>
				New
			</button>
			<button
				class={ "px-3 py-1.5 text-sm rounded-full transition-colors",
					templ.KV("bg-brown-800 text-brown-50 font-medium", qs.Sort == "popular"),
					templ.KV("bg-brown-100 text-brown-700 hover:bg-brown-200", qs.Sort != "popular") }
				hx-get={ buildFeedURL(qs.TypeFilter, "popular") }
				hx-target="#feed-container"
				hx-swap="outerHTML"
			>
				Popular
			</button>
		</div>
	</div>
}

// FeedLoadMoreButton renders a "Load more" button for pagination
templ FeedLoadMoreButton(qs FeedQueryState) {
	<div class="text-center pt-2" x-data="{ loading: false }">
		<button
			class="px-4 py-2 text-sm text-brown-700 bg-brown-100 hover:bg-brown-200 rounded-lg transition-colors disabled:opacity-50"
			hx-get={ buildFeedURLWithCursor(qs.TypeFilter, qs.Sort, qs.NextCursor) }
			hx-target="closest div"
			hx-swap="outerHTML"
			@htmx:before-request="loading = true"
			x-bind:disabled="loading"
		>
			<span x-show="!loading">Load more</span>
			<span x-show="loading" x-cloak>Loading...</span>
		</button>
	</div>
}

// FeedMoreItems renders additional items for "load more" pagination (no filter bar)
templ FeedMoreItems(items []*feed.FeedItem, isAuthenticated bool, modCtx FeedModerationContext, qs FeedQueryState) {
	for _, item := range items {
		@FeedCardWithModeration(item, isAuthenticated, modCtx)
	}
	if qs.NextCursor != "" {
		@FeedLoadMoreButton(qs)
	}
}

// FeedCard renders a single feed item card (without moderation context)
templ FeedCard(item *feed.FeedItem, isAuthenticated bool) {
	@FeedCardWithModeration(item, isAuthenticated, FeedModerationContext{})
}

// FeedCardWithModeration renders a single feed item card with moderation context
templ FeedCardWithModeration(item *feed.FeedItem, isAuthenticated bool, modCtx FeedModerationContext) {
	<div class="feed-card">
		<!-- Author row -->
		<div class="mb-3">
			@components.UserBadge(components.UserBadgeProps{
				ProfileURL:  "/profile/" + item.Author.DID,
				AvatarURL:   getAvatarURL(item.Author.Avatar),
				DisplayName: getDisplayName(item.Author.DisplayName),
				Handle:      item.Author.Handle,
				TimeAgo:     item.TimeAgo,
				Size:        "md",
			})
		</div>
		<!-- Action header -->
		<div class="mb-2 text-sm text-brown-700">
			@ActionText(item)
		</div>
		<!-- Record content (clickable for brews) -->
		switch item.RecordType {
			case lexicons.RecordTypeBrew:
				@FeedBrewContentClickable(item)
			case lexicons.RecordTypeBean:
				if item.Bean != nil {
					<a href={ templ.SafeURL(getFeedItemShareURL(item)) } class="block hover:opacity-90 transition-opacity">
						@components.BeanContent(item.Bean)
					</a>
				}
			case lexicons.RecordTypeRoaster:
				if item.Roaster != nil {
					<a href={ templ.SafeURL(getFeedItemShareURL(item)) } class="block hover:opacity-90 transition-opacity">
						@components.RoasterContent(item.Roaster)
					</a>
				}
			case lexicons.RecordTypeGrinder:
				if item.Grinder != nil {
					<a href={ templ.SafeURL(getFeedItemShareURL(item)) } class="block hover:opacity-90 transition-opacity">
						@components.GrinderContent(item.Grinder)
					</a>
				}
			case lexicons.RecordTypeBrewer:
				if item.Brewer != nil {
					<a href={ templ.SafeURL(getFeedItemShareURL(item)) } class="block hover:opacity-90 transition-opacity">
						@components.BrewerContent(item.Brewer)
					</a>
				}
		}
		<!-- Action bar -->
		if item.SubjectURI != "" && item.SubjectCID != "" {
			@components.ActionBar(components.ActionBarProps{
				SubjectURI:      item.SubjectURI,
				SubjectCID:      item.SubjectCID,
				IsLiked:         item.IsLikedByViewer,
				LikeCount:       item.LikeCount,
				CommentCount:    item.CommentCount,
				ViewURL:         getFeedItemShareURL(item),
				ShowComments:    true,
				ShareURL:        getFeedItemShareURL(item),
				ShareTitle:      getFeedItemShareTitle(item),
				ShareText:       getFeedItemShareText(item),
				IsOwner:         item.IsOwner,
				EditURL:         getEditURL(item),
				DeleteURL:       getDeleteURL(item),
				IsAuthenticated: isAuthenticated,
				IsModerator:     modCtx.IsModerator,
				CanHideRecord:   modCtx.CanHideRecord,
				CanBlockUser:    modCtx.CanBlockUser,
				IsRecordHidden:  modCtx.HiddenURIs[item.SubjectURI],
				AuthorDID:       item.Author.DID,
			})
		}
	</div>
}

// Helper functions for avatar rendering
func getAvatarURL(avatar *string) string {
	if avatar != nil {
		return *avatar
	}
	return ""
}

func getDisplayName(displayName *string) string {
	if displayName != nil {
		return *displayName
	}
	return ""
}

// ActionText renders the action text with clickable links for record names
templ ActionText(item *feed.FeedItem) {
	switch item.RecordType {
		case lexicons.RecordTypeBrew:
			if item.Brew != nil {
				added a
				<a href={ templ.SafeURL(getFeedItemShareURL(item)) } class="underline hover:text-brown-900">new brew</a>
			} else {
				{ item.Action }
			}
		case lexicons.RecordTypeBean:
			if item.Bean != nil {
				added a
				<a href={ templ.SafeURL(getFeedItemShareURL(item)) } class="underline hover:text-brown-900">new bean</a>
			} else {
				{ item.Action }
			}
		case lexicons.RecordTypeRoaster:
			if item.Roaster != nil {
				added a
				<a href={ templ.SafeURL(getFeedItemShareURL(item)) } class="underline hover:text-brown-900">new roaster</a>
			} else {
				{ item.Action }
			}
		case lexicons.RecordTypeGrinder:
			if item.Grinder != nil {
				added a
				<a href={ templ.SafeURL(getFeedItemShareURL(item)) } class="underline hover:text-brown-900">new grinder</a>
			} else {
				{ item.Action }
			}
		case lexicons.RecordTypeBrewer:
			if item.Brewer != nil {
				added a
				<a href={ templ.SafeURL(getFeedItemShareURL(item)) } class="underline hover:text-brown-900">new brewer</a>
			} else {
				{ item.Action }
			}
		default:
			{ item.Action }
	}
}

// FeedBrewContentClickable renders brew content wrapped in a clickable link
templ FeedBrewContentClickable(item *feed.FeedItem) {
	if item.Brew != nil {
		<a
			href={ templ.SafeURL(fmt.Sprintf("/brews/%s?owner=%s", item.Brew.RKey, item.Author.DID)) }
			class="block hover:opacity-90 transition-opacity"
		>
			@components.BrewContent(item.Brew)
		</a>
	}
}

// Helper functions for share button
func getFeedItemShareURL(item *feed.FeedItem) string {
	switch item.RecordType {
	case lexicons.RecordTypeBrew:
		if item.Brew != nil {
			return fmt.Sprintf("/brews/%s?owner=%s", item.Brew.RKey, item.Author.DID)
		}
	case lexicons.RecordTypeBean:
		if item.Bean != nil {
			return fmt.Sprintf("/beans/%s?owner=%s", item.Bean.RKey, item.Author.DID)
		}
	case lexicons.RecordTypeRoaster:
		if item.Roaster != nil {
			return fmt.Sprintf("/roasters/%s?owner=%s", item.Roaster.RKey, item.Author.DID)
		}
	case lexicons.RecordTypeGrinder:
		if item.Grinder != nil {
			return fmt.Sprintf("/grinders/%s?owner=%s", item.Grinder.RKey, item.Author.DID)
		}
	case lexicons.RecordTypeBrewer:
		if item.Brewer != nil {
			return fmt.Sprintf("/brewers/%s?owner=%s", item.Brewer.RKey, item.Author.DID)
		}
	}
	return fmt.Sprintf("/profile/%s", item.Author.DID)
}

func getFeedItemShareTitle(item *feed.FeedItem) string {
	switch item.RecordType {
	case lexicons.RecordTypeBrew:
		if item.Brew != nil && item.Brew.Bean != nil {
			if item.Brew.Bean.Name != "" {
				return item.Brew.Bean.Name
			}
			return item.Brew.Bean.Origin
		}
		return "Coffee Brew"
	case lexicons.RecordTypeBean:
		if item.Bean != nil {
			if item.Bean.Name != "" {
				return item.Bean.Name
			}
			return item.Bean.Origin
		}
		return "Coffee Bean"
	case lexicons.RecordTypeRoaster:
		if item.Roaster != nil {
			return item.Roaster.Name
		}
		return "Roaster"
	case lexicons.RecordTypeGrinder:
		if item.Grinder != nil {
			return item.Grinder.Name
		}
		return "Grinder"
	case lexicons.RecordTypeBrewer:
		if item.Brewer != nil {
			return item.Brewer.Name
		}
		return "Brewer"
	}
	return "Arabica"
}

func getFeedItemShareText(item *feed.FeedItem) string {
	displayName := item.Author.Handle
	if item.Author.DisplayName != nil && *item.Author.DisplayName != "" {
		displayName = *item.Author.DisplayName
	}
	return fmt.Sprintf("Check out this %s by %s on Arabica", item.RecordType, displayName)
}

// getEditURL returns the edit URL for a feed item
func getEditURL(item *feed.FeedItem) string {
	switch item.RecordType {
	case lexicons.RecordTypeBrew:
		if item.Brew != nil {
			return fmt.Sprintf("/brews/%s/edit", item.Brew.RKey)
		}
	}
	// Beans, roasters, grinders, and brewers are edited via modals on the manage page
	return ""
}

// getDeleteURL returns the delete URL for a feed item
func getDeleteURL(item *feed.FeedItem) string {
	switch item.RecordType {
	case lexicons.RecordTypeBrew:
		if item.Brew != nil {
			return fmt.Sprintf("/brews/%s", item.Brew.RKey)
		}
	case lexicons.RecordTypeBean:
		if item.Bean != nil {
			return fmt.Sprintf("/api/beans/%s", item.Bean.RKey)
		}
	case lexicons.RecordTypeRoaster:
		if item.Roaster != nil {
			return fmt.Sprintf("/api/roasters/%s", item.Roaster.RKey)
		}
	case lexicons.RecordTypeGrinder:
		if item.Grinder != nil {
			return fmt.Sprintf("/api/grinders/%s", item.Grinder.RKey)
		}
	case lexicons.RecordTypeBrewer:
		if item.Brewer != nil {
			return fmt.Sprintf("/api/brewers/%s", item.Brewer.RKey)
		}
	}
	return ""
}
