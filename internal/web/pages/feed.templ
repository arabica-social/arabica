package pages

import (
	"arabica/internal/feed"
	"arabica/internal/lexicons"
	"arabica/internal/web/bff"
	"arabica/internal/web/components"
	"fmt"
)

// FeedModerationContext holds moderation state for rendering feed items
type FeedModerationContext struct {
	IsModerator   bool              // User has moderator role
	CanHideRecord bool              // User has hide_record permission
	CanBlockUser  bool              // User has blacklist_user permission
	HiddenURIs    map[string]bool   // URIs that are currently hidden
}

// FeedPartial renders the feed items (for HTMX loading)
templ FeedPartial(items []*feed.FeedItem, isAuthenticated bool) {
	@FeedPartialWithModeration(items, isAuthenticated, FeedModerationContext{})
}

// FeedPartialWithModeration renders feed items with moderation context
templ FeedPartialWithModeration(items []*feed.FeedItem, isAuthenticated bool, modCtx FeedModerationContext) {
	<div class="space-y-4">
		if len(items) > 0 {
			for _, item := range items {
				@FeedCardWithModeration(item, isAuthenticated, modCtx)
			}
		} else {
			<div class="bg-brown-100 rounded-lg p-6 text-center text-brown-700 border border-brown-200">
				<p class="mb-2 font-medium">No activity in the feed yet.</p>
				<p class="text-sm">Be the first to add something!</p>
			</div>
		}
	</div>
}

// FeedCard renders a single feed item card (without moderation context)
templ FeedCard(item *feed.FeedItem, isAuthenticated bool) {
	@FeedCardWithModeration(item, isAuthenticated, FeedModerationContext{})
}

// FeedCardWithModeration renders a single feed item card with moderation context
templ FeedCardWithModeration(item *feed.FeedItem, isAuthenticated bool, modCtx FeedModerationContext) {
	<div class="feed-card">
		<!-- Author row -->
		<div class="mb-3">
			@components.UserBadge(components.UserBadgeProps{
				ProfileURL:  "/profile/" + item.Author.Handle,
				AvatarURL:   getAvatarURL(item.Author.Avatar),
				DisplayName: getDisplayName(item.Author.DisplayName),
				Handle:      item.Author.Handle,
				TimeAgo:     item.TimeAgo,
				Size:        "md",
			})
		</div>
		<!-- Action header -->
		<div class="mb-2 text-sm text-brown-700">
			@ActionText(item)
		</div>
		<!-- Record content (clickable for brews) -->
		switch item.RecordType {
			case lexicons.RecordTypeBrew:
				@FeedBrewContentClickable(item)
			case lexicons.RecordTypeBean:
				@FeedEntityContentClickable(item, FeedBeanContent)
			case lexicons.RecordTypeRoaster:
				@FeedEntityContentClickable(item, FeedRoasterContent)
			case lexicons.RecordTypeGrinder:
				@FeedEntityContentClickable(item, FeedGrinderContent)
			case lexicons.RecordTypeBrewer:
				@FeedEntityContentClickable(item, FeedBrewerContent)
		}
		<!-- Action bar -->
		if item.SubjectURI != "" && item.SubjectCID != "" {
			@components.ActionBar(components.ActionBarProps{
				SubjectURI:      item.SubjectURI,
				SubjectCID:      item.SubjectCID,
				IsLiked:         item.IsLikedByViewer,
				LikeCount:       item.LikeCount,
				CommentCount:    item.CommentCount,
				ViewURL:         getFeedItemShareURL(item),
				ShowComments:    true,
				ShareURL:        getFeedItemShareURL(item),
				ShareTitle:      getFeedItemShareTitle(item),
				ShareText:       getFeedItemShareText(item),
				IsOwner:         item.IsOwner,
				EditURL:         getEditURL(item),
				DeleteURL:       getDeleteURL(item),
				IsAuthenticated: isAuthenticated,
				IsModerator:     modCtx.IsModerator,
				CanHideRecord:   modCtx.CanHideRecord,
				CanBlockUser:    modCtx.CanBlockUser,
				IsRecordHidden:  modCtx.HiddenURIs[item.SubjectURI],
				AuthorDID:       item.Author.DID,
			})
		}
	</div>
}

// Helper functions for avatar rendering
func getAvatarURL(avatar *string) string {
	if avatar != nil {
		return *avatar
	}
	return ""
}

func getDisplayName(displayName *string) string {
	if displayName != nil {
		return *displayName
	}
	return ""
}

// ActionText renders the action text with clickable links for record names
templ ActionText(item *feed.FeedItem) {
	switch item.RecordType {
		case lexicons.RecordTypeBrew:
			if item.Brew != nil {
				added a
				<a href={ templ.SafeURL(getFeedItemShareURL(item)) } class="underline hover:text-brown-900">new brew</a>
			} else {
				{ item.Action }
			}
		case lexicons.RecordTypeBean:
			if item.Bean != nil {
				added a
				<a href={ templ.SafeURL(getFeedItemShareURL(item)) } class="underline hover:text-brown-900">new bean</a>
			} else {
				{ item.Action }
			}
		case lexicons.RecordTypeRoaster:
			if item.Roaster != nil {
				added a
				<a href={ templ.SafeURL(getFeedItemShareURL(item)) } class="underline hover:text-brown-900">new roaster</a>
			} else {
				{ item.Action }
			}
		case lexicons.RecordTypeGrinder:
			if item.Grinder != nil {
				added a
				<a href={ templ.SafeURL(getFeedItemShareURL(item)) } class="underline hover:text-brown-900">new grinder</a>
			} else {
				{ item.Action }
			}
		case lexicons.RecordTypeBrewer:
			if item.Brewer != nil {
				added a
				<a href={ templ.SafeURL(getFeedItemShareURL(item)) } class="underline hover:text-brown-900">new brewer</a>
			} else {
				{ item.Action }
			}
		default:
			{ item.Action }
	}
}

// FeedEntityContentClickable wraps any entity content component in a clickable link
templ FeedEntityContentClickable(item *feed.FeedItem, content func(*feed.FeedItem) templ.Component) {
	<a
		href={ templ.SafeURL(getFeedItemShareURL(item)) }
		class="block hover:opacity-90 transition-opacity"
	>
		@content(item)
	</a>
}

// FeedBrewContentClickable renders brew content wrapped in a clickable link
templ FeedBrewContentClickable(item *feed.FeedItem) {
	if item.Brew != nil {
		<a
			href={ templ.SafeURL(fmt.Sprintf("/brews/%s?owner=%s", item.Brew.RKey, item.Author.Handle)) }
			class="block hover:opacity-90 transition-opacity"
		>
			@FeedBrewContent(item)
		</a>
	}
}

// FeedBrewContent renders brew content in a feed card
templ FeedBrewContent(item *feed.FeedItem) {
	if item.Brew != nil {
		<div class="feed-content-box">
			<!-- Bean info with rating -->
			<div class="flex items-start justify-between gap-3 mb-3">
				<div class="flex-1 min-w-0">
					if item.Brew.Bean != nil {
						<div class="font-bold text-brown-900 text-base">
							if item.Brew.Bean.Name != "" {
								{ item.Brew.Bean.Name }
							} else {
								{ item.Brew.Bean.Origin }
							}
						</div>
						if item.Brew.Bean.Roaster != nil && item.Brew.Bean.Roaster.Name != "" {
							<div class="text-sm text-brown-700 mt-0.5">
								<span class="font-medium">üè≠ { item.Brew.Bean.Roaster.Name }</span>
							</div>
						}
						<div class="text-xs text-brown-600 mt-1 flex flex-wrap gap-x-2 gap-y-0.5">
							if item.Brew.Bean.Origin != "" {
								<span class="inline-flex items-center gap-0.5">üìç { item.Brew.Bean.Origin }</span>
							}
							if item.Brew.Bean.RoastLevel != "" {
								<span class="inline-flex items-center gap-0.5">üî• { item.Brew.Bean.RoastLevel }</span>
							}
							if item.Brew.Bean.Process != "" {
								<span class="inline-flex items-center gap-0.5">üå± { item.Brew.Bean.Process }</span>
							}
							if item.Brew.CoffeeAmount > 0 {
								<span class="inline-flex items-center gap-0.5">‚öñÔ∏è { fmt.Sprintf("%dg", item.Brew.CoffeeAmount) }</span>
							}
						</div>
					}
				</div>
				if item.Brew.Rating > 0 {
					<span class="badge-rating">
						‚≠ê { fmt.Sprintf("%d/10", item.Brew.Rating) }
					</span>
				}
			</div>
			<!-- Brewer -->
			if item.Brew.BrewerObj != nil || item.Brew.Method != "" {
				<div class="mb-2">
					<span class="text-meta">Brewer:</span>
					<span class="text-sm font-semibold text-brown-900">
						if item.Brew.BrewerObj != nil {
							{ item.Brew.BrewerObj.Name }
						} else if item.Brew.Method != "" {
							{ item.Brew.Method }
						}
					</span>
				</div>
			}
			<!-- Brew parameters in compact grid -->
			<div class="grid grid-cols-2 gap-x-4 gap-y-1 text-xs text-brown-700">
				if item.Brew.GrinderObj != nil {
					<div>
						<span class="text-label">Grinder:</span>
						{ " " }{ item.Brew.GrinderObj.Name }
						if item.Brew.GrindSize != "" {
							({ item.Brew.GrindSize })
						}
					</div>
				} else if item.Brew.GrindSize != "" {
					<div>
						<span class="text-label">Grind:</span> { item.Brew.GrindSize }
					</div>
				}
				if len(item.Brew.Pours) > 0 {
					<div class="col-span-2">
						<span class="text-label">Pours:</span>
						for _, pour := range item.Brew.Pours {
							<div class="pl-2 text-brown-600">‚Ä¢ { fmt.Sprintf("%dg @ %s", pour.WaterAmount, bff.FormatTime(pour.TimeSeconds)) }</div>
						}
					</div>
				} else if item.Brew.WaterAmount > 0 {
					<div>
						<span class="text-label">Water:</span> { fmt.Sprintf("%dg", item.Brew.WaterAmount) }
					</div>
				}
				if bff.HasTemp(item.Brew.Temperature) {
					<div>
						<span class="text-label">Temp:</span> { bff.FormatTemp(item.Brew.Temperature) }
					</div>
				}
				if item.Brew.TimeSeconds > 0 {
					<div>
						<span class="text-label">Time:</span> { bff.FormatTime(item.Brew.TimeSeconds) }
					</div>
				}
			</div>
			if item.Brew.TastingNotes != "" {
				<div class="mt-3 text-sm text-brown-800 italic border-t border-brown-200 pt-2">
					"{ item.Brew.TastingNotes }"
				</div>
			}
		</div>
	}
}

// FeedBeanContent renders bean content in a feed card
templ FeedBeanContent(item *feed.FeedItem) {
	if item.Bean != nil {
		<div class="feed-content-box-sm">
			<div class="mb-2">
				<div class="font-bold text-brown-900 text-base">
					if item.Bean.Name != "" {
						{ item.Bean.Name }
					} else {
						{ item.Bean.Origin }
					}
				</div>
				if item.Bean.Roaster != nil && item.Bean.Roaster.Name != "" {
					<div class="text-sm text-brown-700 mt-0.5">
						<span class="font-medium">üè≠ { item.Bean.Roaster.Name }</span>
					</div>
				}
			</div>
			<div class="text-xs text-brown-600 mt-1 flex flex-wrap gap-x-2 gap-y-0.5">
				if item.Bean.Origin != "" {
					<span class="inline-flex items-center gap-0.5">üìç { item.Bean.Origin }</span>
				}
				if item.Bean.RoastLevel != "" {
					<span class="inline-flex items-center gap-0.5">üî• { item.Bean.RoastLevel }</span>
				}
				if item.Bean.Process != "" {
					<span class="inline-flex items-center gap-0.5">üå± { item.Bean.Process }</span>
				}
			</div>
			if item.Bean.Description != "" {
				<div class="mt-2 text-sm text-brown-800 italic">"{ item.Bean.Description }"</div>
			}
		</div>
	}
}

// FeedRoasterContent renders roaster content in a feed card
templ FeedRoasterContent(item *feed.FeedItem) {
	if item.Roaster != nil {
		<div class="feed-content-box-sm">
			<div class="text-base mb-2">
				<span class="font-bold text-brown-900">{ item.Roaster.Name }</span>
			</div>
			<div class="text-xs text-brown-600 mt-1 flex flex-wrap gap-x-2 gap-y-0.5">
				if item.Roaster.Location != "" {
					<span class="inline-flex items-center gap-0.5">üìç { item.Roaster.Location }</span>
				}
				if item.Roaster.Website != "" {
					if safeWebsite := bff.SafeWebsiteURL(item.Roaster.Website); safeWebsite != "" {
						<span class="inline-flex items-center gap-0.5">
							üîó <a href={ templ.SafeURL(safeWebsite) } target="_blank" rel="noopener noreferrer" class="text-brown-800 hover:underline">{ safeWebsite }</a>
						</span>
					}
				}
			</div>
		</div>
	}
}

// FeedGrinderContent renders grinder content in a feed card
templ FeedGrinderContent(item *feed.FeedItem) {
	if item.Grinder != nil {
		<div class="feed-content-box-sm">
			<div class="text-base mb-2">
				<span class="font-bold text-brown-900">{ item.Grinder.Name }</span>
			</div>
			<div class="text-xs text-brown-600 mt-1 flex flex-wrap gap-x-2 gap-y-0.5">
				if item.Grinder.GrinderType != "" {
					<span class="inline-flex items-center gap-0.5">‚öôÔ∏è { item.Grinder.GrinderType }</span>
				}
				if item.Grinder.BurrType != "" {
					<span class="inline-flex items-center gap-0.5">üî© { item.Grinder.BurrType }</span>
				}
			</div>
			if item.Grinder.Notes != "" {
				<div class="mt-2 text-sm text-brown-800 italic">"{ item.Grinder.Notes }"</div>
			}
		</div>
	}
}

// FeedBrewerContent renders brewer content in a feed card
templ FeedBrewerContent(item *feed.FeedItem) {
	if item.Brewer != nil {
		<div class="feed-content-box-sm">
			<div class="text-base mb-2">
				<span class="font-bold text-brown-900">{ item.Brewer.Name }</span>
			</div>
			if item.Brewer.Description != "" {
				<div class="text-sm text-brown-800 italic">"{ item.Brewer.Description }"</div>
			}
		</div>
	}
}

// Helper functions for share button
func getFeedItemShareURL(item *feed.FeedItem) string {
	switch item.RecordType {
	case lexicons.RecordTypeBrew:
		if item.Brew != nil {
			return fmt.Sprintf("/brews/%s?owner=%s", item.Brew.RKey, item.Author.Handle)
		}
	case lexicons.RecordTypeBean:
		if item.Bean != nil {
			return fmt.Sprintf("/beans/%s?owner=%s", item.Bean.RKey, item.Author.Handle)
		}
	case lexicons.RecordTypeRoaster:
		if item.Roaster != nil {
			return fmt.Sprintf("/roasters/%s?owner=%s", item.Roaster.RKey, item.Author.Handle)
		}
	case lexicons.RecordTypeGrinder:
		if item.Grinder != nil {
			return fmt.Sprintf("/grinders/%s?owner=%s", item.Grinder.RKey, item.Author.Handle)
		}
	case lexicons.RecordTypeBrewer:
		if item.Brewer != nil {
			return fmt.Sprintf("/brewers/%s?owner=%s", item.Brewer.RKey, item.Author.Handle)
		}
	}
	return fmt.Sprintf("/profile/%s", item.Author.Handle)
}

func getFeedItemShareTitle(item *feed.FeedItem) string {
	switch item.RecordType {
	case lexicons.RecordTypeBrew:
		if item.Brew != nil && item.Brew.Bean != nil {
			if item.Brew.Bean.Name != "" {
				return item.Brew.Bean.Name
			}
			return item.Brew.Bean.Origin
		}
		return "Coffee Brew"
	case lexicons.RecordTypeBean:
		if item.Bean != nil {
			if item.Bean.Name != "" {
				return item.Bean.Name
			}
			return item.Bean.Origin
		}
		return "Coffee Bean"
	case lexicons.RecordTypeRoaster:
		if item.Roaster != nil {
			return item.Roaster.Name
		}
		return "Roaster"
	case lexicons.RecordTypeGrinder:
		if item.Grinder != nil {
			return item.Grinder.Name
		}
		return "Grinder"
	case lexicons.RecordTypeBrewer:
		if item.Brewer != nil {
			return item.Brewer.Name
		}
		return "Brewer"
	}
	return "Arabica"
}

func getFeedItemShareText(item *feed.FeedItem) string {
	displayName := item.Author.Handle
	if item.Author.DisplayName != nil && *item.Author.DisplayName != "" {
		displayName = *item.Author.DisplayName
	}
	return fmt.Sprintf("Check out this %s by %s on Arabica", item.RecordType, displayName)
}

// getEditURL returns the edit URL for a feed item
func getEditURL(item *feed.FeedItem) string {
	switch item.RecordType {
	case lexicons.RecordTypeBrew:
		if item.Brew != nil {
			return fmt.Sprintf("/brews/%s/edit", item.Brew.RKey)
		}
	}
	// Beans, roasters, grinders, and brewers are edited via modals on the manage page
	return ""
}

// getDeleteURL returns the delete URL for a feed item
func getDeleteURL(item *feed.FeedItem) string {
	switch item.RecordType {
	case lexicons.RecordTypeBrew:
		if item.Brew != nil {
			return fmt.Sprintf("/brews/%s", item.Brew.RKey)
		}
	case lexicons.RecordTypeBean:
		if item.Bean != nil {
			return fmt.Sprintf("/api/beans/%s", item.Bean.RKey)
		}
	case lexicons.RecordTypeRoaster:
		if item.Roaster != nil {
			return fmt.Sprintf("/api/roasters/%s", item.Roaster.RKey)
		}
	case lexicons.RecordTypeGrinder:
		if item.Grinder != nil {
			return fmt.Sprintf("/api/grinders/%s", item.Grinder.RKey)
		}
	case lexicons.RecordTypeBrewer:
		if item.Brewer != nil {
			return fmt.Sprintf("/api/brewers/%s", item.Brewer.RKey)
		}
	}
	return ""
}
